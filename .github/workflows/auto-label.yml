name: üè∑Ô∏è Auto Label

on:
  issues:
    types: [opened, edited]
  pull_request:
    types: [opened, edited, synchronize]

jobs:
  auto-label-issues:
    name: üè∑Ô∏è Label Issues
    runs-on: ubuntu-latest
    if: github.event_name == 'issues'
    timeout-minutes: 5
    permissions:
      issues: write
      contents: read
    
    steps:
      - name: üè∑Ô∏è Auto-label issues
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = issue.body ? issue.body.toLowerCase() : '';
            const labels = [];
            
            // Priority labels based on title/body keywords
            if (title.includes('critical') || body.includes('critical') || 
                title.includes('urgent') || body.includes('urgent')) {
              labels.push('priority: high');
            } else if (title.includes('important') || body.includes('important')) {
              labels.push('priority: medium');
            }
            
            // Type labels based on title patterns
            if (title.startsWith('[bug]') || title.includes('bug') || 
                title.includes('error') || title.includes('issue')) {
              labels.push('type: bug');
            } else if (title.startsWith('[feature]') || title.includes('feature') || 
                       title.includes('enhancement') || title.includes('improvement')) {
              labels.push('type: enhancement');
            } else if (title.startsWith('[question]') || title.includes('question') || 
                       title.includes('help') || title.includes('how to')) {
              labels.push('type: question');
            } else if (title.includes('documentation') || title.includes('docs')) {
              labels.push('type: documentation');
            }
            
            // Component labels based on content
            if (body.includes('whatsapp') || body.includes('authentication') || 
                body.includes('qr code') || body.includes('session')) {
              labels.push('component: whatsapp');
            }
            if (body.includes('audio') || body.includes('tts') || 
                body.includes('elevenlabs') || body.includes('voice')) {
              labels.push('component: audio');
            }
            if (body.includes('mcp') || body.includes('model context protocol') || 
                body.includes('claude')) {
              labels.push('component: mcp');
            }
            if (body.includes('install') || body.includes('setup') || 
                body.includes('configuration') || body.includes('config')) {
              labels.push('component: setup');
            }
            
            // OS labels
            if (body.includes('windows') || body.includes('win32')) {
              labels.push('os: windows');
            } else if (body.includes('macos') || body.includes('darwin') || 
                       body.includes('mac os')) {
              labels.push('os: macos');
            } else if (body.includes('linux') || body.includes('ubuntu')) {
              labels.push('os: linux');
            }
            
            // Add needs-triage for all new issues
            labels.push('status: needs-triage');
            
            // Apply labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: labels
              });
              
              console.log(`Applied labels: ${labels.join(', ')}`);
            }

  auto-label-prs:
    name: üè∑Ô∏è Label Pull Requests  
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    timeout-minutes: 5
    permissions:
      pull-requests: write
      contents: read
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üè∑Ô∏è Auto-label pull requests
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const title = pr.title.toLowerCase();
            const body = pr.body ? pr.body.toLowerCase() : '';
            const labels = [];
            
            // Size labels based on changes
            const changedFiles = pr.changed_files;
            const additions = pr.additions;
            const deletions = pr.deletions;
            const totalChanges = additions + deletions;
            
            if (totalChanges < 50) {
              labels.push('size: small');
            } else if (totalChanges < 200) {
              labels.push('size: medium');
            } else if (totalChanges < 500) {
              labels.push('size: large');
            } else {
              labels.push('size: extra-large');
            }
            
            // Type labels based on title patterns
            if (title.startsWith('fix:') || title.startsWith('bugfix:') || 
                title.includes('fix') || title.includes('bug')) {
              labels.push('type: bugfix');
            } else if (title.startsWith('feat:') || title.startsWith('feature:') || 
                       title.includes('feature') || title.includes('add')) {
              labels.push('type: feature');
            } else if (title.startsWith('docs:') || title.includes('documentation')) {
              labels.push('type: documentation');  
            } else if (title.startsWith('chore:') || title.includes('chore') || 
                       title.includes('maintenance')) {
              labels.push('type: maintenance');
            } else if (title.startsWith('refactor:') || title.includes('refactor')) {
              labels.push('type: refactoring');
            } else if (title.startsWith('test:') || title.includes('test')) {
              labels.push('type: testing');
            } else if (title.startsWith('perf:') || title.includes('performance')) {
              labels.push('type: performance');
            }
            
            // Breaking change detection
            if (title.includes('breaking') || body.includes('breaking change') || 
                title.includes('!:')) {
              labels.push('breaking-change');
            }
            
            // Get changed files to determine components
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });
            
            const changedPaths = files.map(f => f.filename);
            
            // Component labels based on changed files
            if (changedPaths.some(p => p.includes('auth'))) {
              labels.push('component: authentication');
            }
            if (changedPaths.some(p => p.includes('whatsapp'))) {
              labels.push('component: whatsapp');
            }
            if (changedPaths.some(p => p.includes('tts') || p.includes('audio'))) {
              labels.push('component: audio');
            }
            if (changedPaths.some(p => p.includes('test') || p.includes('spec'))) {
              labels.push('component: testing');
            }
            if (changedPaths.some(p => p.includes('.github'))) {
              labels.push('component: ci-cd');
            }
            if (changedPaths.some(p => p.includes('docs/') || p.includes('.md'))) {
              labels.push('component: documentation');
            }
            
            // Draft PR label
            if (pr.draft) {
              labels.push('status: draft');
            } else {
              labels.push('status: ready-for-review');
            }
            
            // Apply labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: labels
              });
              
              console.log(`Applied labels: ${labels.join(', ')}`);
            }

  conflict-detection:
    name: üö® Conflict Detection
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'synchronize'
    timeout-minutes: 5
    permissions:
      pull-requests: write
      contents: read
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üö® Check for merge conflicts
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            
            // Check if PR is mergeable
            if (pr.mergeable === false) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['status: merge-conflict']
              });
              
              // Add a comment about the conflict
              const body = "üö® **Merge Conflict Detected**\n\n" +
                "This pull request has merge conflicts that need to be resolved before it can be merged.\n\n" +
                "**To resolve conflicts:**\n" +
                "1. Sync your branch with the latest changes from the base branch\n" +
                "2. Resolve the conflicts in your local environment\n" +
                "3. Push the resolved changes\n\n" +
                "**Commands to resolve:**\n" +
                "```bash\n" +
                `git checkout ${pr.head.ref}\n` +
                `git pull origin ${pr.base.ref}\n` +
                "# Resolve conflicts in your editor\n" +
                "git add .\n" +
                'git commit -m "Resolve merge conflicts"\n' +
                `git push origin ${pr.head.ref}\n` +
                "```\n\n" +
                "The conflict status will be automatically updated once resolved.";

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: body
              });
            } else if (pr.mergeable === true) {
              // Remove conflict label if it exists
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  name: 'status: merge-conflict'
                });
              } catch (error) {
                // Label might not exist, ignore error
              }
            }