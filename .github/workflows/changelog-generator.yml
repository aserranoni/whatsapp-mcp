name: 📋 Changelog Generator

on:
  release:
    types: [published]
  push:
    branches: [main]
    paths:
      - 'package.json'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to generate changelog for'
        required: false
        default: 'latest'
        type: string
      update_file:
        description: 'Update CHANGELOG.md file'
        required: false
        default: true
        type: boolean

permissions:
  contents: write
  pull-requests: read
  issues: read

jobs:
  detect-version-change:
    name: 🔍 Detect Version Change
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    timeout-minutes: 5
    
    outputs:
      version-changed: ${{ steps.check.outputs.changed }}
      new-version: ${{ steps.check.outputs.version }}
    
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: 🔍 Check version change
        id: check
        run: |
          # Get current version
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "Current version: $CURRENT_VERSION"
          
          # Get previous version
          git checkout HEAD~1 -- package.json 2>/dev/null || echo "No previous version"
          PREV_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "none")
          echo "Previous version: $PREV_VERSION"
          
          # Restore current package.json
          git checkout HEAD -- package.json
          
          if [[ "$CURRENT_VERSION" != "$PREV_VERSION" && "$PREV_VERSION" != "none" ]]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
            echo "Version changed from $PREV_VERSION to $CURRENT_VERSION"
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "No version change detected"
          fi

  generate-changelog:
    name: 📋 Generate Changelog
    runs-on: ubuntu-latest
    needs: detect-version-change
    if: |
      always() && (
        github.event_name == 'release' ||
        github.event_name == 'workflow_dispatch' ||
        needs.detect-version-change.outputs.version-changed == 'true'
      )
    timeout-minutes: 15
    
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 🟢 Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: 📋 Generate changelog content
        id: changelog
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Determine version and range
            let targetVersion, previousTag;
            
            if (context.eventName === 'release') {
              targetVersion = context.payload.release.tag_name.replace('v', '');
            } else if (context.eventName === 'workflow_dispatch') {
              targetVersion = context.payload.inputs.version;
            } else {
              targetVersion = '${{ needs.detect-version-change.outputs.new-version }}';
            }
            
            console.log(`Generating changelog for version: ${targetVersion}`);
            
            // Get all tags
            const { data: tags } = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            
            // Find the previous tag
            if (targetVersion === 'latest' && tags.length > 0) {
              targetVersion = tags[0].name.replace('v', '');
              previousTag = tags.length > 1 ? tags[1].name : null;
            } else {
              const currentTagIndex = tags.findIndex(tag => tag.name === `v${targetVersion}`);
              previousTag = currentTagIndex >= 0 && currentTagIndex < tags.length - 1 
                ? tags[currentTagIndex + 1].name 
                : null;
            }
            
            console.log(`Previous tag: ${previousTag || 'none (first release)'}`);
            
            // Get commits since previous tag
            let commits;
            if (previousTag) {
              const { data: comparison } = await github.rest.repos.compareCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                base: previousTag,
                head: `v${targetVersion}` || 'HEAD'
              });
              commits = comparison.commits;
            } else {
              // First release - get all commits
              const { data: allCommits } = await github.rest.repos.listCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              commits = allCommits;
            }
            
            console.log(`Found ${commits.length} commits to analyze`);
            
            // Categorize commits
            const categories = {
              features: [],
              fixes: [],
              breaking: [],
              docs: [],
              chore: [],
              refactor: [],
              perf: [],
              test: [],
              ci: [],
              other: []
            };
            
            const breakingChangePattern = /BREAKING CHANGE:|!:/;
            const prPattern = /\(#(\d+)\)/;
            
            for (const commit of commits) {
              const message = commit.commit.message;
              const firstLine = message.split('\n')[0];
              const sha = commit.sha.substring(0, 7);
              const author = commit.commit.author.name;
              
              // Extract PR number if present
              const prMatch = firstLine.match(prPattern);
              const prLink = prMatch ? ` ([#${prMatch[1]}](https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${prMatch[1]}))` : '';
              
              const commitInfo = {
                message: firstLine.replace(prPattern, '').trim(),
                sha,
                author,
                prLink,
                fullMessage: message
              };
              
              // Check for breaking changes
              if (breakingChangePattern.test(message) || firstLine.includes('!:')) {
                categories.breaking.push(commitInfo);
              }
              // Categorize by conventional commit type
              else if (firstLine.startsWith('feat')) {
                categories.features.push(commitInfo);
              } else if (firstLine.startsWith('fix')) {
                categories.fixes.push(commitInfo);
              } else if (firstLine.startsWith('docs')) {
                categories.docs.push(commitInfo);
              } else if (firstLine.startsWith('refactor')) {
                categories.refactor.push(commitInfo);
              } else if (firstLine.startsWith('perf')) {
                categories.perf.push(commitInfo);
              } else if (firstLine.startsWith('test')) {
                categories.test.push(commitInfo);
              } else if (firstLine.startsWith('chore') || firstLine.startsWith('build')) {
                categories.chore.push(commitInfo);
              } else if (firstLine.startsWith('ci')) {
                categories.ci.push(commitInfo);
              } else {
                categories.other.push(commitInfo);
              }
            }
            
            // Generate changelog markdown
            let changelog = `# Changelog\n\n`;
            changelog += `## [${targetVersion}] - ${new Date().toISOString().split('T')[0]}\n\n`;
            
            // Breaking Changes (highest priority)
            if (categories.breaking.length > 0) {
              changelog += `### 💥 Breaking Changes\n\n`;
              categories.breaking.forEach(commit => {
                changelog += `- ${commit.message}${commit.prLink} (${commit.sha})\n`;
                
                // Extract breaking change details from commit body
                const breakingMatch = commit.fullMessage.match(/BREAKING CHANGE:\s*([^\n]+)/);
                if (breakingMatch) {
                  changelog += `  - **Breaking**: ${breakingMatch[1]}\n`;
                }
              });
              changelog += '\n';
            }
            
            // Features
            if (categories.features.length > 0) {
              changelog += `### ✨ New Features\n\n`;
              categories.features.forEach(commit => {
                changelog += `- ${commit.message}${commit.prLink} (${commit.sha})\n`;
              });
              changelog += '\n';
            }
            
            // Bug Fixes
            if (categories.fixes.length > 0) {
              changelog += `### 🐛 Bug Fixes\n\n`;
              categories.fixes.forEach(commit => {
                changelog += `- ${commit.message}${commit.prLink} (${commit.sha})\n`;
              });
              changelog += '\n';
            }
            
            // Performance
            if (categories.perf.length > 0) {
              changelog += `### ⚡ Performance Improvements\n\n`;
              categories.perf.forEach(commit => {
                changelog += `- ${commit.message}${commit.prLink} (${commit.sha})\n`;
              });
              changelog += '\n';
            }
            
            // Refactoring
            if (categories.refactor.length > 0) {
              changelog += `### 🔧 Code Refactoring\n\n`;
              categories.refactor.forEach(commit => {
                changelog += `- ${commit.message}${commit.prLink} (${commit.sha})\n`;
              });
              changelog += '\n';
            }
            
            // Documentation
            if (categories.docs.length > 0) {
              changelog += `### 📚 Documentation\n\n`;
              categories.docs.forEach(commit => {
                changelog += `- ${commit.message}${commit.prLink} (${commit.sha})\n`;
              });
              changelog += '\n';
            }
            
            // Tests
            if (categories.test.length > 0) {
              changelog += `### ✅ Tests\n\n`;
              categories.test.forEach(commit => {
                changelog += `- ${commit.message}${commit.prLink} (${commit.sha})\n`;
              });
              changelog += '\n';
            }
            
            // CI/CD
            if (categories.ci.length > 0) {
              changelog += `### 🚀 CI/CD\n\n`;
              categories.ci.forEach(commit => {
                changelog += `- ${commit.message}${commit.prLink} (${commit.sha})\n`;
              });
              changelog += '\n';
            }
            
            // Chore
            if (categories.chore.length > 0) {
              changelog += `### 🧹 Maintenance\n\n`;
              categories.chore.forEach(commit => {
                changelog += `- ${commit.message}${commit.prLink} (${commit.sha})\n`;
              });
              changelog += '\n';
            }
            
            // Other
            if (categories.other.length > 0) {
              changelog += `### 📝 Other Changes\n\n`;
              categories.other.forEach(commit => {
                changelog += `- ${commit.message}${commit.prLink} (${commit.sha})\n`;
              });
              changelog += '\n';
            }
            
            // Add contributors section
            const contributors = [...new Set(commits.map(c => c.commit.author.name))];
            if (contributors.length > 0) {
              changelog += `### 👥 Contributors\n\n`;
              changelog += `Thanks to these contributors for this release:\n\n`;
              contributors.forEach(contributor => {
                changelog += `- @${contributor}\n`;
              });
              changelog += '\n';
            }
            
            // Add comparison link
            if (previousTag) {
              changelog += `### 🔗 Links\n\n`;
              changelog += `- [Full Changelog](https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${previousTag}...v${targetVersion})\n`;
              changelog += `- [Release](https://github.com/${context.repo.owner}/${context.repo.repo}/releases/tag/v${targetVersion})\n\n`;
            }
            
            console.log('Generated changelog:');
            console.log(changelog);
            
            // Save changelog content
            const changelogPath = 'generated-changelog.md';
            fs.writeFileSync(changelogPath, changelog);
            
            return {
              content: changelog,
              version: targetVersion,
              path: changelogPath,
              hasBreaking: categories.breaking.length > 0,
              commitCount: commits.length
            };

      - name: 📤 Upload changelog artifact
        uses: actions/upload-artifact@v4
        with:
          name: changelog-${{ steps.changelog.outputs.version }}
          path: generated-changelog.md
          retention-days: 30

      - name: 📋 Update CHANGELOG.md file
        if: github.event.inputs.update_file != 'false'
        run: |
          echo "📋 Updating CHANGELOG.md file..."
          
          if [ ! -f CHANGELOG.md ]; then
            echo "Creating new CHANGELOG.md"
            cat > CHANGELOG.md << 'EOF'
          # Changelog
          
          All notable changes to this project will be documented in this file.
          
          The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
          and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
          
          EOF
          fi
          
          # Insert new changelog content after the header
          NEW_CONTENT=$(cat generated-changelog.md | sed '1,2d')  # Remove first two lines (# Changelog and empty line)
          
          # Create temporary file with new content
          head -n 6 CHANGELOG.md > temp_changelog.md
          echo "" >> temp_changelog.md
          echo "$NEW_CONTENT" >> temp_changelog.md
          
          # Add existing content (skip header)
          if [ $(wc -l < CHANGELOG.md) -gt 6 ]; then
            tail -n +7 CHANGELOG.md >> temp_changelog.md
          fi
          
          mv temp_changelog.md CHANGELOG.md
          
          echo "✅ CHANGELOG.md updated"

      - name: 📝 Create changelog PR
        if: github.event_name != 'release' && github.event.inputs.update_file != 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const version = '${{ steps.changelog.outputs.version }}';
            
            // Check if there are changes to commit
            const { exec } = require('child_process');
            const { promisify } = require('util');
            const execAsync = promisify(exec);
            
            try {
              await execAsync('git diff --exit-code CHANGELOG.md');
              console.log('No changes to CHANGELOG.md');
              return;
            } catch (error) {
              console.log('Changes detected in CHANGELOG.md');
            }
            
            // Create branch and commit changes
            const branchName = `changelog/v${version}`;
            
            await execAsync(`git config user.name "github-actions[bot]"`);
            await execAsync(`git config user.email "github-actions[bot]@users.noreply.github.com"`);
            await execAsync(`git checkout -b ${branchName}`);
            await execAsync(`git add CHANGELOG.md`);
            await execAsync(`git commit -m "docs: update changelog for v${version}"`);
            await execAsync(`git push origin ${branchName}`);
            
            // Create pull request
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `📋 Update changelog for v${version}`,
              head: branchName,
              base: 'main',
              body: "## 📋 Automated Changelog Update\n\n" +
                "This PR updates the changelog for version `v" + version + "`.\n\n" +
                "### Changes\n" +
                "- Added changelog entries for v" + version + "\n" +
                "- Organized commits by type (features, fixes, etc.)\n" +
                "- Included contributor list\n" +
                "- Added comparison links\n\n" +
                "### Review\n" +
                "- [ ] Verify changelog entries are accurate\n" +
                "- [ ] Check formatting and links\n" +
                "- [ ] Confirm version number is correct\n\n" +
                "*This PR was automatically generated by the changelog workflow.*"
            });
            
            console.log(`Created PR #${pr.number}: ${pr.html_url}`);

      - name: 📊 Changelog summary
        run: |
          echo "## 📋 Changelog Generation Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ steps.changelog.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commits Analyzed**: ${{ steps.changelog.outputs.commitCount }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Breaking Changes**: ${{ steps.changelog.outputs.hasBreaking }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Generated**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📎 Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- Changelog artifact uploaded as \`changelog-${{ steps.changelog.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ github.event.inputs.update_file }}" != "false" ]; then
            echo "- CHANGELOG.md file updated" >> $GITHUB_STEP_SUMMARY
          fi