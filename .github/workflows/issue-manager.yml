name: 🎯 Issue Management

on:
  issues:
    types: [opened, edited, closed, reopened]
  issue_comment:
    types: [created]
  schedule:
    # Run daily at 01:00 UTC for maintenance tasks
    - cron: '0 1 * * *'
  workflow_dispatch:
    inputs:
      action:
        description: 'Management action to run'
        required: true
        default: 'triage'
        type: choice
        options:
          - triage
          - cleanup
          - metrics
          - all

permissions:
  issues: write
  contents: read
  pull-requests: read

jobs:
  validate-issue:
    name: ✅ Validate New Issues
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'opened'
    timeout-minutes: 5
    
    steps:
      - name: ✅ Validate issue template compliance
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const title = issue.title;
            
            console.log('🔍 Validating issue template compliance...');
            
            let validationErrors = [];
            let suggestions = [];
            
            // Check if using a template (has certain markers)
            const templateMarkers = [
              '## Bug Description',
              '## Feature Summary', 
              '## Your Question',
              'Pre-flight checklist'
            ];
            
            const usesTemplate = templateMarkers.some(marker => body.includes(marker));
            
            if (!usesTemplate) {
              // Check for free-form issues that might need template guidance
              if (title.toLowerCase().includes('bug') || 
                  title.toLowerCase().includes('error') || 
                  title.toLowerCase().includes('issue')) {
                suggestions.push('🐛 This looks like a bug report. Please use the bug report template for better tracking.');
              } else if (title.toLowerCase().includes('feature') || 
                         title.toLowerCase().includes('enhancement') || 
                         title.toLowerCase().includes('request')) {
                suggestions.push('✨ This looks like a feature request. Please use the feature request template.');
              } else if (title.toLowerCase().includes('question') || 
                         title.toLowerCase().includes('help') || 
                         title.toLowerCase().includes('how')) {
                suggestions.push('❓ This looks like a question. Please use the question template for faster responses.');
              }
            } else {
              console.log('✅ Issue uses a template');
            }
            
            // Validate title format
            if (title.length < 10) {
              validationErrors.push('❌ Title is too short (minimum 10 characters)');
            }
            if (title.length > 100) {
              validationErrors.push('❌ Title is too long (maximum 100 characters)');
            }
            
            // Check for empty sections in template
            if (usesTemplate) {
              const emptyPatterns = [
                'Describe the issue you\'re experiencing...',
                'What would you like to know?',
                'A brief, clear description of the feature',
                'placeholder'
              ];
              
              const hasEmptyPlaceholders = emptyPatterns.some(pattern => 
                body.includes(pattern)
              );
              
              if (hasEmptyPlaceholders) {
                validationErrors.push('❌ Please fill out all template sections');
              }
            }
            
            // Create validation comment if needed
            if (validationErrors.length > 0 || suggestions.length > 0) {
              let comment = '## 📋 Issue Validation\n\n';
              
              if (validationErrors.length > 0) {
                comment += '### ❌ Issues Found\n';
                validationErrors.forEach(error => {
                  comment += `- ${error}\n`;
                });
                comment += '\n';
              }
              
              if (suggestions.length > 0) {
                comment += '### 💡 Suggestions\n';
                suggestions.forEach(suggestion => {
                  comment += `- ${suggestion}\n`;
                });
                comment += '\n';
              }
              
              comment += '### 🔗 Helpful Links\n';
              comment += '- [Bug Report Template](https://github.com/' + context.repo.owner + '/' + context.repo.repo + '/issues/new?template=bug_report.yml)\n';
              comment += '- [Feature Request Template](https://github.com/' + context.repo.owner + '/' + context.repo.repo + '/issues/new?template=feature_request.yml)\n';
              comment += '- [Question Template](https://github.com/' + context.repo.owner + '/' + context.repo.repo + '/issues/new?template=question.yml)\n';
              comment += '- [Documentation](https://github.com/' + context.repo.owner + '/' + context.repo.repo + '#readme)\n\n';
              comment += '*This is an automated message. Please update your issue if needed.*';
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: comment
              });
              
              // Add needs-more-info label if validation failed
              if (validationErrors.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['status: needs-more-info']
                });
              }
            }

  welcome-new-users:
    name: 👋 Welcome New Users
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'opened'
    timeout-minutes: 5
    
    steps:
      - name: 👋 Welcome first-time contributors
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const author = issue.user.login;
            
            console.log(`🔍 Checking if ${author} is a first-time contributor...`);
            
            // Check if this is the user's first issue
            const { data: userIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              creator: author,
              state: 'all'
            });
            
            if (userIssues.length === 1) {
              console.log('👋 First-time contributor detected');
              
              const welcomeMessage = "👋 **Welcome to the WhatsApp MCP Server project!**\n\n" +
                "Thank you for opening your first issue, @" + author + "! We appreciate your interest in the project.\n\n" +
                "### 📚 Getting Started\n" +
                "- Make sure you've read our [README](https://github.com/" + context.repo.owner + "/" + context.repo.repo + "#readme)\n" +
                "- Check out the [documentation](https://github.com/" + context.repo.owner + "/" + context.repo.repo + "/tree/main/docs)\n" +
                "- Join our [discussions](https://github.com/" + context.repo.owner + "/" + context.repo.repo + "/discussions) for community support\n\n" +
                "### 🤝 Contributing\n" +
                "If you're interested in contributing:\n" +
                "- Check out our [contributing guidelines](https://github.com/" + context.repo.owner + "/" + context.repo.repo + "/blob/main/CONTRIBUTING.md)\n" +
                "- Look for issues labeled `good first issue` or `help wanted`\n" +
                "- Feel free to ask questions in the discussions\n\n" +
                "### ⏰ What's Next?\n" +
                "- Our team will review your issue soon\n" +
                "- You can help by providing more details if requested\n" +
                "- Follow the issue for updates\n\n" +
                "Thanks for helping make this project better! 🚀";

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: welcomeMessage
              });
              
              // Add first-time contributor label
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['status: first-time-contributor']
              });
            }

  duplicate-detection:
    name: 🔍 Duplicate Detection
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'opened'
    timeout-minutes: 10
    
    steps:
      - name: 🔍 Check for duplicate issues
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();
            
            console.log('🔍 Checking for potential duplicates...');
            
            // Get recent issues to compare against
            const { data: recentIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              per_page: 100,
              sort: 'created',
              direction: 'desc'
            });
            
            const potentialDuplicates = [];
            
            for (const existingIssue of recentIssues) {
              if (existingIssue.number === issue.number) continue;
              
              const existingTitle = existingIssue.title.toLowerCase();
              const existingBody = (existingIssue.body || '').toLowerCase();
              
              // Simple similarity check
              let similarity = 0;
              
              // Title similarity (high weight)
              const titleWords = title.split(/\s+/);
              const existingTitleWords = existingTitle.split(/\s+/);
              const commonTitleWords = titleWords.filter(word => 
                word.length > 3 && existingTitleWords.includes(word)
              );
              
              if (titleWords.length > 0) {
                similarity += (commonTitleWords.length / titleWords.length) * 0.7;
              }
              
              // Body similarity (lower weight)
              if (body && existingBody) {
                const bodyWords = body.split(/\s+/).filter(word => word.length > 4);
                const existingBodyWords = existingBody.split(/\s+/).filter(word => word.length > 4);
                const commonBodyWords = bodyWords.filter(word => 
                  existingBodyWords.includes(word)
                );
                
                if (bodyWords.length > 10) {
                  similarity += (commonBodyWords.length / bodyWords.length) * 0.3;
                }
              }
              
              // Check for exact error messages
              if (body && existingBody) {
                const errorPattern = /error[:\s]([^.\n]{10,})/gi;
                const errors = [...body.matchAll(errorPattern)];
                const existingErrors = [...existingBody.matchAll(errorPattern)];
                
                for (const error of errors) {
                  for (const existingError of existingErrors) {
                    if (error[1] && existingError[1] && 
                        error[1].trim() === existingError[1].trim()) {
                      similarity += 0.5;
                    }
                  }
                }
              }
              
              if (similarity > 0.6) {
                potentialDuplicates.push({
                  issue: existingIssue,
                  similarity: similarity
                });
              }
            }
            
            // Sort by similarity
            potentialDuplicates.sort((a, b) => b.similarity - a.similarity);
            
            if (potentialDuplicates.length > 0) {
              console.log(`Found ${potentialDuplicates.length} potential duplicates`);
              
              let comment = '🔍 **Potential Duplicate Detection**\n\n';
              comment += 'This issue might be similar to:\n\n';
              
              potentialDuplicates.slice(0, 3).forEach((dup, index) => {
                const conf = Math.round(dup.similarity * 100);
                comment += `${index + 1}. #${dup.issue.number} - ${dup.issue.title} (${conf}% similarity)\n`;
              });
              
              comment += '\n**Before proceeding:**\n';
              comment += '- Please check if any of these existing issues address your problem\n';
              comment += '- If this is indeed a duplicate, please comment on the existing issue instead\n';
              comment += '- If this is different, please add more details to help us distinguish it\n\n';
              comment += '*This is an automated check. Feel free to proceed if this is not a duplicate.*';
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: comment
              });
              
              // Add potential duplicate label for high similarity
              if (potentialDuplicates[0].similarity > 0.8) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['status: potential-duplicate']
                });
              }
            }

  smart-assignment:
    name: 🎯 Smart Assignment
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && (github.event.action == 'opened' || github.event.action == 'edited')
    timeout-minutes: 5
    
    steps:
      - name: 🎯 Auto-assign based on expertise
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();
            const labels = issue.labels.map(label => label.name);
            
            console.log('🎯 Determining expert assignment...');
            
            // Define expertise mapping
            const experts = {
              // Main maintainer gets all critical issues
              'your-username': {
                keywords: ['critical', 'urgent', 'security', 'breaking'],
                components: ['core', 'architecture'],
                priority: 1
              }
              // Add more experts as the project grows
              // 'expert-username': {
              //   keywords: ['audio', 'tts', 'elevenlabs'],
              //   components: ['component: audio'],
              //   priority: 2  
              // }
            };
            
            let bestMatch = null;
            let maxScore = 0;
            
            for (const [username, expertise] of Object.entries(experts)) {
              let score = 0;
              
              // Check keywords in title and body
              expertise.keywords.forEach(keyword => {
                if (title.includes(keyword) || body.includes(keyword)) {
                  score += 3;
                }
              });
              
              // Check component labels
              expertise.components.forEach(component => {
                if (labels.includes(component)) {
                  score += 2;
                }
              });
              
              // Priority bonus (higher priority = higher score)
              score += (10 - expertise.priority);
              
              if (score > maxScore) {
                maxScore = score;
                bestMatch = username;
              }
            }
            
            // Auto-assign if we found a good match and no one is assigned
            if (bestMatch && maxScore > 5 && issue.assignees.length === 0) {
              console.log(`Assigning to ${bestMatch} (score: ${maxScore})`);
              
              await github.rest.issues.addAssignees({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                assignees: [bestMatch]
              });
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `🎯 Auto-assigned to @${bestMatch} based on expertise match.\n\n*This is an automated assignment. Feel free to reassign if needed.*`
              });
            }

  stale-issue-management:
    name: 🧹 Stale Issue Management  
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && (github.event.inputs.action == 'cleanup' || github.event.inputs.action == 'all'))
    timeout-minutes: 15
    
    steps:
      - name: 🧹 Mark stale issues
        uses: actions/github-script@v7
        with:
          script: |
            const staleAfterDays = 30;
            const closeAfterDays = 7; // days after being marked stale
            const staleDate = new Date();
            staleDate.setDate(staleDate.getDate() - staleAfterDays);
            
            const closeDate = new Date();
            closeDate.setDate(closeDate.getDate() - (staleAfterDays + closeAfterDays));
            
            console.log('🧹 Checking for stale issues...');
            
            // Get all open issues
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });
            
            for (const issue of issues) {
              // Skip PRs and issues with certain labels
              if (issue.pull_request) continue;
              
              const labels = issue.labels.map(l => l.name);
              const skipLabels = [
                'priority: high',
                'priority: critical', 
                'status: pinned',
                'status: in-progress',
                'type: enhancement'
              ];
              
              if (labels.some(label => skipLabels.includes(label))) {
                continue;
              }
              
              const updatedAt = new Date(issue.updated_at);
              const isStale = labels.includes('status: stale');
              
              // Close issues that have been stale too long
              if (isStale && updatedAt < closeDate) {
                console.log(`Closing stale issue #${issue.number}`);
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: "🔒 **Auto-closing stale issue**\n\n" +
                    "This issue has been automatically closed due to inactivity.\n\n" +
                    "**Why was this closed?**\n" +
                    "- No activity for " + (staleAfterDays + closeAfterDays) + " days\n" +
                    "- Marked as stale with no follow-up\n\n" +
                    "**Need to reopen?**\n" +
                    "- Comment on this issue or create a new one\n" +
                    "- Provide updated information if the issue persists\n" +
                    "- Reference this issue number: #" + issue.number + "\n\n" +
                    "Thank you for your contribution! 🙏"
                });
                
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  state: 'closed',
                  state_reason: 'not_planned'
                });
              }
              // Mark issues as stale
              else if (!isStale && updatedAt < staleDate) {
                console.log(`Marking issue #${issue.number} as stale`);
                
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['status: stale']
                });
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: "⏰ **This issue has been marked as stale**\n\n" +
                    "This issue hasn't had any activity for " + staleAfterDays + " days and will be automatically closed in " + closeAfterDays + " days if no further activity occurs.\n\n" +
                    "**To keep this issue active:**\n" +
                    "- Add a comment with updates or progress\n" +
                    "- Add relevant labels or assignees\n" +
                    "- Reference it in related PRs or issues\n\n" +
                    "**If this issue is still relevant:**\n" +
                    "- Please comment to let us know\n" +
                    "- Provide any additional context\n" +
                    "- Update the description if needed\n\n" +
                    "The stale label will be removed automatically once there's new activity."
                });
              }
            }

  issue-metrics:
    name: 📊 Issue Metrics
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && (github.event.inputs.action == 'metrics' || github.event.inputs.action == 'all'))
    timeout-minutes: 10
    
    steps:
      - name: 📊 Generate issue metrics
        uses: actions/github-script@v7
        with:
          script: |
            console.log('📊 Generating issue metrics...');
            
            // Get issues from the last 30 days
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            
            const { data: allIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              per_page: 100,
              since: thirtyDaysAgo.toISOString()
            });
            
            // Filter out PRs
            const issues = allIssues.filter(issue => !issue.pull_request);
            
            // Calculate metrics
            const openIssues = issues.filter(i => i.state === 'open').length;
            const closedIssues = issues.filter(i => i.state === 'closed').length;
            const totalIssues = issues.length;
            
            // Response time (time to first response)
            let responseTimes = [];
            for (const issue of issues) {
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number
              });
              
              if (comments.length > 0) {
                const firstResponse = new Date(comments[0].created_at);
                const created = new Date(issue.created_at);
                const responseTime = (firstResponse - created) / (1000 * 60 * 60); // hours
                responseTimes.push(responseTime);
              }
            }
            
            const avgResponseTime = responseTimes.length > 0 
              ? (responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length).toFixed(1)
              : 'N/A';
            
            // Issue types
            const bugReports = issues.filter(i => 
              i.labels.some(l => l.name.includes('bug')) ||
              i.title.toLowerCase().includes('bug')
            ).length;
            
            const featureRequests = issues.filter(i =>
              i.labels.some(l => l.name.includes('enhancement') || l.name.includes('feature')) ||
              i.title.toLowerCase().includes('feature')
            ).length;
            
            const questions = issues.filter(i =>
              i.labels.some(l => l.name.includes('question')) ||
              i.title.toLowerCase().includes('question')
            ).length;
            
            // Create metrics summary
            const metrics = "## 📊 Issue Metrics (Last 30 Days)\n\n" +
              "### 📈 Overview\n" +
              "- **Total Issues**: " + totalIssues + "\n" +
              "- **Open Issues**: " + openIssues + "\n" +
              "- **Closed Issues**: " + closedIssues + "\n" +
              "- **Close Rate**: " + (totalIssues > 0 ? Math.round((closedIssues / totalIssues) * 100) : 0) + "%\n\n" +
              "### ⏱️ Response Time\n" +
              "- **Average First Response**: " + avgResponseTime + " hours\n\n" +
              "### 🏷️ Issue Types\n" +
              "- **Bug Reports**: " + bugReports + "\n" +
              "- **Feature Requests**: " + featureRequests + "\n" +
              "- **Questions**: " + questions + "\n" +
              "- **Other**: " + (totalIssues - bugReports - featureRequests - questions) + "\n\n" +
              "### 📅 Generated\n" +
              new Date().toISOString().split('T')[0] + " UTC\n\n" +
              "---\n" +
              "*This report is automatically generated daily.*";

            console.log(metrics);
            
            // Could post this as a discussion or save to file
            // For now, just log it
            core.summary.addRaw(metrics);
            await core.summary.write();